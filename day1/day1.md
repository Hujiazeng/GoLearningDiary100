# 反射
~~这是一个强大的工具, 除非真的有必要, 否则应当避免使用或小心使用~~

抽象记忆:   **卡牌反射罩**

被检查的变量首先被转换成空接口类型, 空接口内部实现保存了对象的类型和指针

**两个常用方法**: 
<u>reflect.TypeOf 返回反射对象类型</u>
<u>reflect.ValueOf 返回反射对象值</u>

___
**反射得到的对象都有许多方法来检查和操作它们**
##### Value对象的方法: 
>1. **Type** 返回反射对象的Type类型(等价reflect.TypeOf返回值)
>2. **Kind** 返回常量表示类型(总是返回底层类型)
>3. **Interface**得到接口值(从反射对象得到接口值)
>4. **Int, Float, Bool, Complex复数, String**方法可以获取存储在内部的值(调用不同类型方法会报错)
>5. **SetInt, SetFloat...** 可以修改设置值 
>> 不是所有内容都可以修改
>> 解决方法: **<u>传地址</u>**
>
>6. **CanSet**方法测试是否可修改设置
>7. **Elem** 指向指针指向的值
>8. **NumField** 获取字段数量
>9. **Field(index)** 获取对应索引字段
>10. **Method(index).Call(nil)** 调用结构体指定方法
___
##### Type对象的方法:
> 1. **Kind** 返回常量标识类型
> 2. **Name** 只有Type对象才有Name

反射可以从接口值反射到对象，也可以从对象反射回接口值(v.Interface可以得到接口值)
结构体有定义String方法时, fmt打印时会直接调用并返回

___
**反射中有些内容需要用地址才能改变的**
    CanSet 判断是否可修改
    若不可修改:
        1. ValueOf传递值地址, v:=reflect.ValueOf(x)值拷贝x生成的v,并不能通过v修改到x的状态
        2. 使用Elem指针所指向的值(v:=reflect.ValueOf(&x)的类型是指针类型), v.Elem().SetString()
        3. 修改成功
        特例: 结构体中的字段必须大写(可导出)才可被修改

